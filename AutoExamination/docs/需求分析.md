# 问题定义

中文名为数字的解决：https://blog.csdn.net/zhujiangtaotaise/article/details/74424157
中文乱码的解决：

## 问题 
自动生成小学四则运算题目
## 说明
+ 运算数：自然数，真分数，带分数
+ 运算符：+,−,×,÷
+ 子表达式：()
+ 运算规则：算术运算
+ 题目形式：`expression = `，expression 指表达式

# 需求分析

+ 控制题目数量(-n 参数)。控制生成的题目数量
+ 限制运算数范围(-r 参数)。限制表达式中运算数的范围
+ 限制运算符。不超过3个。
+ 计算过程限制。控制表达式的内容以保证运算过程的中间结果的限制。
    1. 中间结果不能产生负数
+ 运算结果限制。结果为分数或自然数。
+ 不重复表达式。一次运行生成的题目不能重复。即任何两道题目不能通过有限次交换+和×左右的算术表达式变换为同一道题目。


# 可行性分析
## 整体问题分析
>虽然实际上我是通过了解波兰表达式后，才能想出下面的内容。
>但我还是想看看试试能不能在通过逻辑推论实现从无到有推算出解决方法。
  + 算术表达式运算顺序：先优先级高后优先级低，同级别从左到右，括号内先运算。
  + 计算机可实现的计算顺序：先进先出(队列)，先入后出(栈)，中序遍历(二叉树)，
1. 初步分析：设表达式a+bxc+dxe
    + 分析表达式运算顺序
        1. bxc
        2. dxe
        3. a + bxc
        4. a + bxc + dxe
    + 分析数据流（变化的数据状态，变化的原因)
        1. a,b,c,d,e————初始化
        2. a,bxc,d,e———— x(b,c)
        3. a,bxc,dxe———— x(d,e)
        4. a+bxc,dxe———— +(a, bxc)
        5. a+bxc,dxe———— +(a+bxc, dxe)
    + 分析结论：
        1. 若能给运算符按运算顺序排序，并标记运算符的操作对象，则计算就能通过遍历运算符然后实现运算。
        2. 运算不是一条线就直接到结果，如2->4->5,3->5，需要多条分支的计算结果逐渐合并到结果。且分析知，合并是高优先级运算结束后的结果在从左到右的运算。
        3. 低优先级的运算符的运算对象可能是高优先级运算的结果。
        4. 高优先级运算符一旦运算完毕，就只剩下其结果还有意义。
2. 设计考虑
    1. 应该先对运算符表达式的运算顺序排序，并标记运算数。
    2. 每运算一次后，就应该只保留结果，抛弃无用的运算数和运算符，以避免对程序逻辑造成影响。
    3. 当运算数本省是更高级运算的结果时候，无法直接标记运算数。故需要间接标记运算数
3. 尝试设计1
    1. 当可以直接标记时，将运算符放在其两个操作数后面，表示运算这个两个数
    2. 若运算数是高级运算结果，显然可以把高级运算标记当作其结果，在规则1进行标记
    3. 预览标记：abcx+dex+
    4. 分析：从左到右遍历，遇到运算符就计算
        1. 运算bxc -> a(bxc)+dex+
        2. 运算a+(bxc) -> (a+(bxc))dex+
        3. 运算dxe -> (a+(bxc))(dxe)+
        4. 运算(a+(bxc)) + (dxe) ->((a+(bxc)) + (dxe))
    5. 结论：设计可行

4. 探寻转换方法：将a+bxc+dxe变成abcx+dex+
    1. 首先从左到右遍历a+bxc+dxe
    2. 变换后运算数的顺序与遍历顺序相同
    2. 变换后运算符顺序遍历顺序局部相反，整体相同。
    3. 相反的遍历顺序都是从低级别运算符遍历到高级别运算符
    4. 故在遍历时候将运算符入栈，若优先级高于栈顶则入栈，否则依次出栈运算符appen到转换表达式子后面，知道栈顶优先级低于运算符或栈空才入账。
    5. 经分析，连续入栈对应着高优先级先运算，出栈后再入栈对应从左到右运算.故转换方法可行。
5. 分析子表达式：设表达式 `a+bx(c+d)+e`
    1. 括号内的表达式先运算，也就是说，括号所包围的是一个能计算出运算数的表达式。
    2. 转换成顺序表达式应该为`abcd+x+e+`
    3. 分析转换过程
        1. 遍历到+ ，入栈
        2. 遍历到x , 入栈
        3. 遍历到+ , 入栈
        4. 遍历到d), 出栈依次+x+
        5. 遍历到+， 入栈
        6. 结束遍历，出栈+
    4. 分析
        1. 若栈内还有运算符，则说明这些运算符的对象涉及到子表达式的结果，显然应该在子表达式计算完成后在出栈以表示运算。
        2. 同理，当遍历子表达式结束时候，应该将子表达式内的运算依次弹帐，才能表示子表达式先运算。
        3. 故当遇到子表达式时候应该屏蔽“遇低优先级运算符则出栈的规则”，当子表达式结束应该将子表达式的运算依次弹栈。

## 生成表达式
逆波兰表达式没有括号，优先级由遍历顺序自动决定。同时可以随时计算中间结果。故可以先生成逆波兰表达式，然后在转换成数学表达式。

## 控制题目数量可行性分析
可通过计数循环限制题目数量

## 限制运算数范围
+ 通过求模运算将运算数现在在指定范围
+ 对于分数可自定义专门的求模运算。

# 限制运算符。不超过3个。
限制运算符的产生次数即可

# 计算过程限制。
中间结果不能产生负数
+ 方法一。每次生成一个运算符，确定操作数后就进行验证，验证不通过则重新生成
+ 方法二。先确定操作数，然后确定在指定条件下可以执行的运算，再生成运算符

## 运算结果限制。
结果为分数或自然数。
全程使用分数计算，当分数可约的时候，则约分到最简。若分母为1则表示自然数。

## 不重复表达式。
一次运行生成的题目不能重复。
+ 若结果不同，则题目不重复
+ 若结果相同，不知道怎么处理，目前先不处理。
